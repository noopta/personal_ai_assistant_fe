# GraphRAG Frontend Integration Guide

**Endpoint:** `POST /agent-rag-demo`
**Purpose:** Demo streaming endpoint for GraphRAG with sample data
**Status:** Ready for developer testing

---

## Quick Start

### Endpoint Details

- **URL:** `https://api.airthreads.ai:5001/agent-rag-demo`
- **Method:** `POST`
- **Content-Type:** `application/json`
- **Response:** SSE stream (default) or JSON

### Request Format

```typescript
interface RAGDemoRequest {
  query: string;      // User's email query
}
```

**Note:** This endpoint only supports streaming (SSE). There is no non-streaming mode.

### Response Format (SSE Stream)

```
event: metadata
data: {"query":"...","intent":{...},"candidate_count":100,"result_count":5,"timing":{...}}

data: {"token":"Your"}

data: {"token":" oldest"}

data: {"token":" email"}

...

event: complete
data: {"status":"complete","timing":{"first_token":0.4,"total":1.3,"tokens":150}}
```

---

## Frontend Implementation

### React/TypeScript Example

```typescript
import { useState } from 'react';

interface Message {
  role: 'user' | 'assistant';
  content: string;
}

export function RAGDemoChat() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isStreaming, setIsStreaming] = useState(false);

  const sendMessage = async () => {
    if (!input.trim()) return;

    // Add user message
    const userMessage: Message = { role: 'user', content: input };
    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsStreaming(true);

    try {
      const response = await fetch('https://api.airthreads.ai:5001/agent-rag-demo', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          query: input
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      // Handle SSE stream
      const reader = response.body!.getReader();
      const decoder = new TextDecoder();

      let assistantMessage: Message = { role: 'assistant', content: '' };
      setMessages(prev => [...prev, assistantMessage]);

      let buffer = '';
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = JSON.parse(line.slice(6));

            if (data.token) {
              // Append token to assistant message
              assistantMessage.content += data.token;
              setMessages(prev => {
                const updated = [...prev];
                updated[updated.length - 1] = { ...assistantMessage };
                return updated;
              });
            }
          } else if (line.startsWith('event: complete')) {
            console.log('Stream complete!');
          }
        }
      }
    } catch (error) {
      console.error('Stream error:', error);
      setMessages(prev => [
        ...prev,
        { role: 'assistant', content: `Error: ${error}` }
      ]);
    } finally {
      setIsStreaming(false);
    }
  };

  return (
    <div className="rag-demo-chat">
      <div className="messages">
        {messages.map((msg, idx) => (
          <div key={idx} className={`message ${msg.role}`}>
            {msg.content}
          </div>
        ))}
      </div>

      <div className="input-area">
        <input
          value={input}
          onChange={e => setInput(e.target.value)}
          onKeyPress={e => e.key === 'Enter' && sendMessage()}
          placeholder="Try: 'whats my oldest email' or 'show me recent meetings'"
          disabled={isStreaming}
        />
        <button onClick={sendMessage} disabled={isStreaming}>
          {isStreaming ? 'Streaming...' : 'Send'}
        </button>
      </div>
    </div>
  );
}
```

### JavaScript (Vanilla) Example

```javascript
async function queryRAGDemo(query) {
  const response = await fetch('https://api.airthreads.ai:5001/agent-rag-demo', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ query })
  });

  const reader = response.body.getReader();
  const decoder = new TextDecoder();

  let buffer = '';
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';

    for (const line of lines) {
      if (line.startsWith('data: ')) {
        const data = JSON.parse(line.slice(6));

        if (data.token) {
          // Display token immediately
          displayToken(data.token);
        }
      } else if (line.startsWith('event: complete')) {
        const completionData = JSON.parse(lines[lines.indexOf(line) + 1].slice(6));
        console.log('Timing:', completionData.timing);
      }
    }
  }
}

function displayToken(token) {
  const messageDiv = document.getElementById('assistant-message');
  messageDiv.textContent += token;
}
```

### Using EventSource (Alternative SSE Library)

```typescript
function queryWithEventSource(query: string) {
  // Note: EventSource doesn't support POST, so you'd need to use a different approach
  // or use the fetch API as shown above

  const eventSource = new EventSource(
    `https://api.airthreads.ai:5001/agent-rag-demo?query=${encodeURIComponent(query)}`
  );

  eventSource.addEventListener('metadata', (e) => {
    const metadata = JSON.parse(e.data);
    console.log('Metadata:', metadata);
  });

  eventSource.onmessage = (e) => {
    const data = JSON.parse(e.data);
    if (data.token) {
      displayToken(data.token);
    }
  };

  eventSource.addEventListener('complete', (e) => {
    const timing = JSON.parse(e.data).timing;
    console.log('Complete:', timing);
    eventSource.close();
  });

  eventSource.onerror = (error) => {
    console.error('SSE error:', error);
    eventSource.close();
  };
}
```

---

## Example Queries to Test

### Super Fast (0.05-0.1s)
```
"whats the total count of my emails"
"whats my oldest email"
"whats my newest email"
```

### With Streaming (0.4s first token, 1.3s total)
```
"show me recent meetings"
"coffee chats this week"
"linkedin messages"
"emails about Q1 planning"
```

### Follow-up Questions (0.8s)
```
User: "whats my oldest email"
Bot: [returns oldest email]

User: "tell me more about it"
Bot: [uses conversation memory - faster!]

User: "what's the subject?"
Bot: [uses conversation memory]
```

---

## Performance Metrics

### Expected Response Times

| Query Type | First Token | Total Time | Notes |
|------------|-------------|------------|-------|
| Count queries | N/A | 0.05s | No streaming (instant) |
| Oldest/Newest | N/A | 0.08s | No streaming (instant) |
| Simple search | 0.4s | 1.3s | Streaming |
| Follow-up | 0.4s | 0.8s | Uses memory |
| Cached query | N/A | 0.002s | Redis cache hit |

### SSE Event Timeline

```
0.000s - Request received
0.001s - Send metadata event
0.400s - First token event (âš¡ this is what user sees!)
0.450s - Token events streaming...
1.300s - Complete event with timing
```

---

## UI/UX Recommendations

### 1. Visual Feedback During Streaming

```tsx
<div className="message assistant">
  {message.content}
  {isCurrentlyStreaming && <span className="cursor">â–‹</span>}
</div>
```

### 2. Display Metadata

```tsx
{metadata && (
  <div className="metadata">
    <span>Found {metadata.result_count} results</span>
    <span>Query type: {metadata.intent.query_type}</span>
    {metadata.timing.first_token && (
      <span>First token: {metadata.timing.first_token}s</span>
    )}
  </div>
)}
```

### 3. Show Performance Badge

```tsx
{timing && timing.total < 0.1 && (
  <span className="badge fast">âš¡ Instant (0.0{Math.round(timing.total * 100)}s)</span>
)}
```

### 4. Conversation Memory Indicator

```tsx
{isFollowUp && (
  <div className="context-indicator">
    ðŸ’­ Using conversation context
  </div>
)}
```

---

## Hidden Dev UI Example

### Simple Hidden Chat Component

```tsx
'use client';

import { useState } from 'react';
import { RAGDemoChat } from './RAGDemoChat';

export function DevTools() {
  const [showRAGDemo, setShowRAGDemo] = useState(false);

  // Show/hide with Ctrl+Shift+R
  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      if (e.ctrlKey && e.shiftKey && e.key === 'R') {
        setShowRAGDemo(prev => !prev);
      }
    };
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, []);

  if (!showRAGDemo) return null;

  return (
    <div className="fixed bottom-4 right-4 w-96 h-[500px]
                    bg-white shadow-2xl rounded-lg border-2 border-purple-500
                    flex flex-col z-50">
      <div className="bg-purple-600 text-white p-3 rounded-t-lg flex justify-between items-center">
        <div>
          <h3 className="font-bold">ðŸš€ GraphRAG Demo</h3>
          <p className="text-xs opacity-75">Developer Testing Only</p>
        </div>
        <button onClick={() => setShowRAGDemo(false)} className="text-white">
          âœ•
        </button>
      </div>

      <RAGDemoChat />

      <div className="bg-gray-100 p-2 text-xs text-gray-600 rounded-b-lg">
        <p>Sample data â€¢ 1000 emails â€¢ Ctrl+Shift+R to toggle</p>
      </div>
    </div>
  );
}
```

---

## Styling Example

```css
.rag-demo-chat {
  display: flex;
  flex-direction: column;
  height: 100%;
  background: #f9fafb;
}

.messages {
  flex: 1;
  overflow-y: auto;
  padding: 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.message {
  padding: 0.75rem 1rem;
  border-radius: 0.5rem;
  max-width: 85%;
  word-wrap: break-word;
}

.message.user {
  background: #3b82f6;
  color: white;
  align-self: flex-end;
}

.message.assistant {
  background: white;
  border: 1px solid #e5e7eb;
  align-self: flex-start;
}

.message.assistant .cursor {
  display: inline-block;
  animation: blink 1s infinite;
  margin-left: 2px;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

.input-area {
  display: flex;
  gap: 0.5rem;
  padding: 1rem;
  border-top: 1px solid #e5e7eb;
  background: white;
}

.input-area input {
  flex: 1;
  padding: 0.5rem;
  border: 1px solid #d1d5db;
  border-radius: 0.375rem;
  font-size: 0.875rem;
}

.input-area button {
  padding: 0.5rem 1rem;
  background: #8b5cf6;
  color: white;
  border: none;
  border-radius: 0.375rem;
  font-weight: 500;
  cursor: pointer;
}

.input-area button:disabled {
  background: #9ca3af;
  cursor: not-allowed;
}

.badge.fast {
  display: inline-block;
  padding: 0.125rem 0.5rem;
  background: #10b981;
  color: white;
  border-radius: 9999px;
  font-size: 0.75rem;
  margin-left: 0.5rem;
}
```

---

## Testing Checklist

- [ ] Streaming works (tokens appear one by one)
- [ ] First token appears in < 0.5s
- [ ] Total response completes in < 2s
- [ ] Follow-up questions work (conversation memory)
- [ ] Error handling works (try invalid query)
- [ ] UI shows streaming cursor
- [ ] Performance badges display correctly
- [ ] Mobile responsive
- [ ] Keyboard shortcuts work (Enter to send)
- [ ] Hidden by default (dev-only)

---

## Notes

- **Sample Data Only**: This endpoint uses the 1000 generated test emails, not real user data
- **No Authentication**: No auth required for demo (uses fixed test user)
- **Conversation Memory**: Each session maintains last 10 conversation turns
- **Redis Caching**: Repeated queries are cached for 24 hours
- **Rate Limited**: 100 requests per 60 seconds

---

## Next Steps

1. Test with curl/Postman to verify endpoint works
2. Implement basic React component
3. Add hidden UI toggle (Ctrl+Shift+R)
4. Test streaming performance
5. Add performance metrics display
6. Get developer feedback
7. Plan integration with real user data

---

**Status:** Ready for developer testing! ðŸš€
